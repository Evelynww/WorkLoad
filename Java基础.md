# 1、JVM vs JRE vs JDK

JVM(Java Virtual Machine)Java虚拟机，它是用来运行Java字节码的，针对不同的操作系统，JVM有不同的实现，保证同一字节码文件在不同操作系统的运行结果是一致的。

JRE(Java Runtime Environment)Java运行环境，它包括了JVM,<font color = 'green'>Java类库，Java命令和其它的一些基础构件</font>，用于运行已编译的Java程序，如果我们只需要运行一个已经编译的Java程序的话就安装JRE即可。

JDK(Java Development Kit)Java开发工具包，它是功能齐全的Java SDK, 包括JRE以及<font color='green'>编译器和工具</font>，如果我们需要创建和编译程序就必须安装JDK.

# 2、为什么说Java语言"编译与解释并存"

高级编程语言根据<font color='green'>程序的执行方式</font>分为编译型和解释型。编译型就是指编译器<font color='green'>针对特定的操作系统</font>将源代码一次性翻译成可以被平台执行的机器码；解释型是指解释器对源程序<font color='green'>逐行解释成特定的机器码</font>并立即执行。Java语言同时拥有这两种语言的特性。首先它经过编译步骤生成字节码<font color='green'>(编译型)</font>，然后在虚拟机上解释执行字节码。<font color='green'>(解释型)</font>

# 3、字符串常量和字符型常量的区别

（1）形式上，字符串常量的关键字是String,用双引号括起来；字符型常量的关键字是char,用单引号括起来。

（2）含义上，字符型常量相当于一个ASCII码值，可以参与表达式运算，而字符串常量代表的是该字符串在内存中的存放位置，是一个地址值。

（3）占用内存：字符型常量占用2个字节的内存空间，字符串常量根据它的长度不同占用空间不同，长度越大，占用空间越大。

# 4、continue\break\return的区别

continue和break都用于循环中。continue表示跳出本次循环，进入下一轮循环。break表示直接跳出循环。

return是方法的出口，返回方法的结果。

# 5、Java泛型？什么是类型擦除

Java泛型就是将类型检查提前到编译器的一种方法。泛型的一个典型的应用就是在集合中。我们知道数组是用来存储一定个数的同一类型的对象的。但是数组的弊端也很明显，就是长度一旦确定就没法修改，只能重新开辟空间进行数据转移。并且数组的操作也比较单一。因此为了满足不同的需求，设计出集合这一类型。最初的集合设计是一个集合可以储存任意类型的对象的。但是这其实是个不好的特征，因为这样的话我们就需要在程序中写大量的类型检查判断。因此引入泛型。

泛型有一个特性就是类型擦除。意思就是编译时我们首先将泛型类型加上，检查完了之后再在字节码中删除泛型信息，也就是说我们得到的最终的字节码种是不包含任何泛型信息的。以你如果我们在运行期添加了其它类型的对象是不会报错的。

常用的通配符有：

`?`：未知类型

`E`: Element元素

`K`: Key键

`V`: Value值

`T`: Type类型

这些通配符是可以随意使用的，只不过为了可读性这样规定。

# 6、`==`和equals的区别

`==`可以用于基本数据类型和引用数据类型的比较。当用于比较基本数据类型时，比较的是基本数据类型代表的值是否相等，比较引用数据类型时，比较的是两个对象的地址值是否相等。

equals只能用于比较引用数据类型。它的使用分为两种情况，当类没有重写equals方法时，它和`==`是一样的，都是比较地址值。当类重写了equals方法时，比较的是对象的内容是否相等。

# 7、hashCode()和equals()方法

hashCode()方法是用来生成对象的散列码的。

这里主要涉及的一个问题就是重写equals方法时必须要重写hashcode()方法。原因就是hashCode()方法存在一个碰撞的问题，不同对象的hashcode()可能得到的结果是一样的。而equals肯定是不一样的。所以说我们在重写equals方法的时候必须重写hashCode()方法。

# 8、基本数据类型占用空间和存储

byte,short,int,long(1/2/4/8)

> 有符号
>
> byte: $-2^7$~$2^7-1$
>
> short: $-2^{15}$​~$2^{15}-1$
>
> int: $-2^{31}$​~$2^{31}-1$​
>
> long:$-2^{63}$​​​~$2^{63}-1$​​​

float,double(4,8)

float: 32位  符号位1，指数位8，尾数位23

double: 64位 符号位1，指数位11， 尾数位52

char(2)

boolean(1 or 2根据操作系统有所不同)

# 9、自动装箱和拆箱

发生于编译器。

自动装箱：基本数据类型用对应的引用类型包装

自动拆箱：引用类型转换为基本数据类型。

Byte,Short,Integer,Long这四种包装类默认创建了[-128,127]的缓存数据，当使用自动装箱初始化对象时，如果指定的数值在这一范围内，则这些对象是同一对象。如果超出范围或者使用构造方法创建的话，则不是同一对象，需要在堆中重新开辟空间存放。

Charater有[0,127]的缓存空间，Boolean直接返回true或false

Float和Double没有默认缓存数据。

# 10、Java值传递

基本数据类型传递值，引用数据类型传递地址。

# 11、重载和重写

- 重载是发生在同一个类中的。它的含义是针对不同的输入有不同的处理。重载的方法的要求：

> 参数列表一定要不同：参数个数或参数类型
>
> 必须要相同的：方法名
>
> 可以不同的：返回值类型。

- 重写是继承关系中，子类对父类已有方法的重新实现

> 两同一大两小：
>
> 两同：方法名相同，参数列表相同
>
> 一大：子类方法的访问权限要比父类方法的权限更大
>
> 两小：子类方法返回值类型要比父类方法返回值类型更小或相等；子类方法声明抛出的异常类型要比父类方法声明抛出的异常类更小或相等。

# 12、面向对象三大特征

封装、继承、多态

封装：将对象内部的属性封装在内部，只向外留接口进行调用。

继承：类之间具有is a的这种关系，比如小明、小红、小芳都是学生，都有学生的一些属性。

多态：一个对象具有多个状态，主要表现为父类的引用指向子类的实例。

# 13、String,StringBuffer,StringBuilder的区别

String:不可变。底层结构是final修饰的字符串数组，线程安全，不可修改。

StringBuffer：可变。线程安全。因为它对方法加了同步锁或者对调用的方法加了同步锁。

StringBuilder: 可变，线程不安全。

String: 操作少量数据

StringBuilder:单线程下，操作大字符串

StringBuffer:多线程下，操作大字符串

# 14、反射

应用：框架、动态代理。

## 14.2 反射的基础知识

提供在运行期操作类。但是造成绕过类型检查的问题。

### 获取Class对象的四种方式

- 类名.class
- 对象名.getClass()
- Class.forName(类的全路径);
- ClassLoader.loadClass(类的全路径);

### 反射的基本操作

> - 获取Class对象targetClass
> - 获取类中所有方法：targetClass.getDeclaredMethods();
> - 获取类中所有属性：targetClass.getDeclaredFields();
> - 操作public修饰的属性或者方法：先根据名称获取
>   - Method method = targetClass.getDeclaredMethod("名称",参数类型.class);
>   - Field field = targetClass.getDeclaredField("名称");
>   - method.invoke(对象名，"参数");
>   - field.set(对象名,"参数")
> - 如果需要操作private方法。需要先setAccessible(true);

## 14.2 代理模式

使用<font color='green'>代理对象来代替对真实对象的访问</font>，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。

### 静态代理

1、被代理类接口和实现类

2、代理类同样实现接口，注入被代理类对象。在代理类的对应方法调用被代理类中的对应方法。从而就可以屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

3、用代理类对象调用方法。

**弊端：**静态代理方式需要对每个目标类创建代理类，并且扩展功能时要同步修改被代理类和代理类的对象方法。

### JDK动态代理

**动态代理：**在运行时动态生成类字节码并加载到JVM中。日常开发中使用的相对较少，但是框架中使用很多。

只能代理实现了接口的类。

核心：InvocationHandler接口和Proxy类

Proxy类中使用最多的方法是newProxyInstance()方法，用来生成一个代理对象。需要传入的参数有：类加载器，handler,代理类实现的接口。

因此我们需要定义被代理类实现InvocationHandler接口，注入被代理对象，重写其中的invoke方法。invoke()方法包含的参数有：<font color='green'>动态生成的代理对象</font>，方法名，方法的参数。

当使用用Proxy类的newProxyInstance()方法动态生成的代理对象调用方法时，实际会调用实现了InvocationHandler接口的类的invoke()方法。因此可以在invoke()方法中调用被代理类的方法以及定义一些方法执行前后的逻辑。

### CGlib动态代理

可以代理没有实现接口的类。

核心：Enhancer类和MethodInterceptor接口。

自定义一个类实现MethodInterceptor接口,重写intercept方法来拦截增强被代理类。intercept()方法的参数：被代理对象，被拦截方法，方法的参数，代理对象。

然后通过Enhancer类的create()方法来获取被代理类，要<font color='green'>先对Enhancer对象设置类加载器、被代理类和拦截器</font>。当代理类调用方法的时候，实际调用的是intercept方法。



# 15、Java异常类

Java的异常都由Throwable类派生而来，分为Error和Exception，Error表示的是错误，是程序无法处理的错误，不能通过catch来捕获，如虚拟机运行错误，虚拟机内存溢出等。

Exception就是异常。其中又分为检查型异常和非检查型异常。检查型异常指的是必须要进行处理才能通过编译的那些异常。比如IO异常（找不到文件，终端异常）,SQL异常，找不到类异常等。非检查型异常指的是不catch也可以通过编译，但是运行时会报错的这些异常。比如说算术异常、空指针异常、下标越界异常等。

# 16、IO流

按流向分为输入流和输出流。

按角色分为节点流和处理流。

按操作单元分为字节流（Stream）和字符流(Reader/Writer)。

# 17、IO模型

IO模型应用于当程序需要内核空间的数据时，需要向操作系统进行申请，将数据取出，拷贝到用户空间。主要的模型包括BIO,NIO,AIO

BIO(Blocked IO):指的是阻塞式IO。阻塞式IO简单描述就是用户程序发起对内核空间数据的申请，然后进程阻塞，一直到内核空间将数据准备好之后然后去读取的整个过程都是不能做其它事情的。

NIO(Nonblock IO):非阻塞式IO。非阻塞式IO指的就是用户程序发起申请后，可以去做其它事情。但是它需要轮询内核是否将数据准备好，如果数据准备好了，才阻塞，去拷贝数据。NIO的实现是IO多路复用的思想。通过一个Selector多路复用器，然后其下绑定了多个Channel，每个Channel有一个缓冲区，Selector监听缓冲区是否有数据，如果有就开始拷贝数据。

AIO(Asyn...IO): 异步IO。异步IO这里使用了一个事件回调的机制。意思就是不像NIO有一个轮询了，而是内核准备好了数据就去通知用户程序可以开始拷贝数据了。

