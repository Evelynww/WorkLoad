# 1、对线程和进程的理解

进程是程序的一次执行过程，是系统运行的基本单位。线程是更小的一个运行单位，一个进程可以产生多个线程。多个线程之间会共享堆和方法区的对象，同时他们也会有各自独有的内存空间，包括：程序计数器、虚拟机栈、本地方法栈。

> <font color = 'red'>程序计数器为什么要私有？</font>
>
> 程序计数器有两个功能：
>
> - 字节码解释器通过改变程序计数器来依次读取指令，从而实现程序的流程控制。
> - 程序计数器会保存线程的执行状态，这样当发生线程切换后再切换回来时就可以从原来的状态继续执行下去。
>
> <font color = 'red'>虚拟机栈为什么要私有？</font>
>
> 我们知道我们的方法其实就是通过一个个栈帧在栈中压入弹出的过程来实现的。虚拟机栈保存的是局部变量表，操作数栈，动态链接，方法出口等信息，这些肯定各个线程要私有。
>
> <font color = 'red'>本地方法栈为什么要私有？</font>
>
> 本地方法栈和虚拟机栈保存的内容差不多，只不过它是针对于本地方法的(native)

> <font color = 'red'>线程和进程的区别？</font>
>
> - 线程之间会共享一些内存空间，而进程一般不会。
> - 线程切换的效率比进程高。

# 2、线程的生命周期

新建-就绪-运行-阻塞-销毁

# 3、死锁

多个线程并发可能会导致死锁。死锁就是多个线程都在等待其中的一个或多个线程释放某个资源。

> <font color = 'red'>产生死锁的条件？</font>
>
> 互斥：某个资源任意一个时刻只能被一个线程占用
>
> 请求与保持：一个进程因请求资源而阻塞的时候，它自己占有的资源不会释放。
>
> 不剥夺：线程的资源只能自己释放，别的线程没法剥夺。
>
> 循环等待：若干线程之间形成头尾相接的循环等待资源的关系。
>
> <font color = 'red'>如何预防死锁？</font>
>
> 从上面的四个条件去考虑。
>
> 互斥条件不能被破坏。
>
> 破坏请求与保持条件：一次性申请所有资源
>
> 破坏不剥夺条件：当一个线程没有申请到自己所需的资源的时候，它可以主动释放自己拥有的资源。
>
> 破坏循环等待条件：反向释放资源。

# 4、sleep()方法和wait()方法的区别

- 同：两者都可以暂停线程的执行
- 异
  - sleep()方法不会释放锁，wait()方法要释放
  - sleep()方法就是用来暂停线程执行，而wait()方法是用于线程间通信
  - sleep()方法执行完成后，线程会自动苏醒。而wait()方法执行后需要其它线程调用notify()或者notifyAll()方法唤醒它。

# 5、为什么创建线程的时候必须调用start()方法而不是直接调用run()方法？

当我们new一个Thread时，线程进行新建状态。调用start()方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后，线程开始运行。start()方法的作用就是进行一些准备工作，自动执行run()方法。但是我们直接调用run()方法的话其实相当于是在调用一个普通方法，而不是以多线程的方式执行。

# 6、synchronized关键字

synchronized关键字是用来解决线程访问资源的同步性的，它保证同一事件访问资源的只有一个线程。

synchronized关键字可以用于修饰方法和代码块。当修饰静态方法时，是对类进行加锁；当修饰实例方法时，是对对象加锁。修饰代码块时，可以自定义加锁的内容。

从底层来看，修饰方法的时候，是通过一个ACC_SYNCHRONIZED访问标识来声明。而修饰代码块的时候，是通过moniterenter和moniterexit来知识代码块的开始和结束。他们的本质都是取得monitor对象来实现。

JDK1.6以后对synchronized关键字的锁做了优化，即无锁、偏向锁、轻量级锁、重量级锁。

# 7、volatile关键字

volatile关键字的作用：

- 线程访问共享资源时，首先是从本地内存中拷贝到自己的一个缓存中。那么这就存在一个不一致的问题，也就是说如果两个线程都拷贝一个10到自己的缓存中，其中一个线程先修改了，然后写入了。但是另外一个线程还是从缓存中的值去修改，最后写入。那么结果就存在问题。而volatile关键字就是指整个对象是一个“危险的”对象，必须从内存中去取。
- volatile可以防止指令重排。多线程的情况下，指令重排可能会产生一些空指针问题。

# 8、ThreadLocal

对于某个对象来说，不同的线程想要各自有自己的不同值，就可以使用ThreadLocal关键字。它其实底层是一个ThreadLocalMap.通过get和set方法来获取和修改其中的对象。

# 9、线程池

创建线程的方法有：

- 继承Thread类，实现run()方法。-->有局限性，因为Java单继承
- 实现Runnable接口，重写run()方法-->无返回值，无法抛出异常
- 实现Callable接口，重写call()方法。-->有返回值，可抛出异常
- 线程池的方式-->重复使用线程资源，减少线程创建和销毁的资源消耗

> ThreadPoolExecutor()方法，重要的参数：
>
> - corePoorSize:最小可同时运行的线程数量
> - MaxPoolSize：最大同时运行的线程数量
> - workQueue：工作队列
> - handler：饱和策略
>
> 

# 10、原子类



# 11、AQS

